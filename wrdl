#! /usr/bin/python3
import argparse
import collections
import os
import random
import string
import time


class Wrdl:
    ANSI_DARK_GRAY = "\033[1;30m"
    ANSI_GREEN = "\033[0;32m"
    ANSI_YELLOW = "\033[0;33m"
    ANSI_WHITE = "\033[1;37m"
    ANSI_BOLD = "\033[1m"
    ANSI_RED = "\033[0;31m"

    MARKERS = {
        -1: f" {ANSI_YELLOW}",
        0: f" {ANSI_DARK_GRAY}",
        1: f" {ANSI_GREEN}",
        None: " ",
    }

    class AlreadyGuessed(ValueError):
        pass

    class InvalidGuess(ValueError):
        pass

    class GameOver(RuntimeError):
        pass

    class NoSuchDictionary(OSError):
        pass

    class OutOfGuesses(RuntimeError):
        pass

    def __init__(self, length=5, max_guesses=6, force_starting_word=None):
        length = min(max(int(length), 2), 15)
        self.__dictionary = None
        try:
            self.read_dictionary(length)
        except OSError:
            raise self.NoSuchDictionary(
                f"No dictionary loaded for {length}-letter words."
            )
        self.__completed_games = 0
        self.__max_guesses = max(int(max_guesses), 1)
        self.__scores = list()
        self.__streak = 0
        self.reset(force_starting_word)

    def auto_guess(self, draw=True):
        try:
            self.enter_guess(
                random.choice(self._plausible_words()), verbose=True, draw=draw
            )
        except self.GameOver as message:
            print(message)
        if not self.solved:
            print("Calculating my next guess...")

    def demo(self):
        self.play(demo=True)

    def draw(self):
        for i, guess in enumerate(self.__valid_guesses):
            print(self.ANSI_BOLD, end="")
            for grade, letter in zip(self._evaluate_guess(i), guess):
                print(f"[{self.MARKERS[grade]}{letter}{self.ANSI_WHITE} ]", end="")
            print()
        for _ in range(self.max_guesses - len(self.__valid_guesses)):
            print(self.ANSI_BOLD, end="")
            print("[   ]" * len(self.secret_word))
        print()
        self.draw_keyboard()

    def draw_keyboard(self):
        for i, row in enumerate(("QWERTYUIOP", "ASDFGHJKL", "ZXCVBNM")):
            print(self.ANSI_BOLD, end="")
            print(" " * 3 * i, end="")
            for letter in row:
                marker = self.MARKERS[self.__guessed_letters.get(letter)]
                print(f"[{marker}{letter}{self.ANSI_WHITE} ]", end="")
            print()
        print()

    def enter_guess(self, guess=None, verbose=False, draw=False):
        try:
            if guess is None:
                self.guess(input(f"Enter a {len(self.secret_word)}-letter guess: "))
            else:
                self.guess(guess)
            print()
        except (self.AlreadyGuessed, self.InvalidGuess) as message:
            print(message)
        except self.OutOfGuesses as message:
            self.you_lose(message)
        except (EOFError, KeyboardInterrupt) as message:
            self.you_quit()
        else:
            if self.solved:
                self.you_win()
            else:
                if verbose:
                    plausible_words = self._plausible_words()
                    if len(plausible_words) > 1:
                        print(
                            len(plausible_words),
                            "word possibilities remain after last guess.",
                        )
                    elif len(plausible_words) == 1:
                        print("The auto-guesser has determined the answer.")
                        print("One more auto guess will solve the puzzle.")
                    else:
                        raise RuntimeError(
                            "No plausible words remain but " "the puzzle is unsolved."
                        )

        if draw and not self.solved:
            self.draw()

    def guess(self, word):
        self.__valid_guesses.append(self._validate_guess(word))
        if not self.solved and len(self.__valid_guesses) >= self.max_guesses:
            raise self.OutOfGuesses("Better luck next time!")
        return self.solved

    def play(self, demo=True):
        if self.__valid_guesses:
            self.reset()
        if demo:
            print("Playing in demo mode.")
        self.draw()
        while not self.solved:
            try:
                if demo:
                    time.sleep(4)
                    os.system("clear")
                    self.auto_guess()
                else:
                    self.enter_guess()
            except self.GameOver:
                break

    def read_dictionary(self, length):
        with open("dictionary.txt") as wordfile:
            self.__dictionary = list(
                filter(
                    None,
                    set(
                        self._validate_guess(word, length=length, fail_silently=True)
                        for word in wordfile
                    ),
                )
            )

    def reset(self, force_starting_word=None):
        self.__secret_word = None
        if force_starting_word is not None:
            force_starting_word = force_starting_word.upper()
            if force_starting_word in self.__dictionary:
                self.__secret_word = force_starting_word
        if self.__secret_word is None:
            self.__secret_word = random.choice(self.__dictionary)
        self.__auto_guess_model = [string.ascii_uppercase] * len(self.__secret_word)
        self.__guessed_letters = dict()
        self.__valid_guesses = list()

    def you_lose(self, message, draw=True):
        self.__streak = 0
        self.__completed_games += 1
        if draw:
            self.draw()
        print(message)
        print(f"Answer: {self.ANSI_BOLD}{self.ANSI_RED}{self.secret_word}")
        raise self.GameOver(message)

    def you_quit(self):
        message = "Game ended prematurely. Thanks for playing!"
        print()
        print(message)
        self.__streak = 0
        raise self.GameOver(message)

    def you_win(self, draw=True):
        self.__streak += 1
        self.__completed_games += 1
        self.__scores.append(len(self.__valid_guesses))
        if draw:
            self.draw()
        print(f"{self.ANSI_BOLD}{self.win_message}")
        self.stats()

    def _evaluate_guess(self, index=-1):
        letter_counts = collections.Counter(self.secret_word)
        guess_letter_counts = collections.defaultdict(int)
        for position, letter in enumerate(self.__valid_guesses[int(index)]):
            guess_letter_counts[letter] += 1
            if self.secret_word[position] == letter:
                self.__guessed_letters[letter] = 1
                self.__auto_guess_model[position] = letter
            elif letter in self.secret_word:
                if letter_counts[letter] >= guess_letter_counts[letter]:
                    self.__guessed_letters[letter] = -1
                    self.__auto_guess_model[position] = "".join(
                        char
                        for char in self.__auto_guess_model[position]
                        if char != letter
                    )
                else:
                    self.__guessed_letters[letter] = 0
            else:
                self.__guessed_letters[letter] = 0
            yield self.__guessed_letters[letter]
        possible_letters = "".join(
            (
                letter
                for letter in string.ascii_uppercase
                if self.__guessed_letters.get(letter) != 0
            )
        )
        for i, letter_set in enumerate(self.__auto_guess_model):
            if len(letter_set) > len(possible_letters):
                self.__auto_guess_model[i] = possible_letters

    def _plausible_words(self):
        return list(
            word
            for word in self.__dictionary
            if all(
                letter in self.__auto_guess_model[position]
                for position, letter in enumerate(word)
            )
            and all(
                misplaced_letter in word
                for misplaced_letter in "".join(
                    char
                    for char in string.ascii_uppercase
                    if self.__guessed_letters.get(char) == -1
                )
            )
        )

    def _validate_guess(self, guess, length=None, fail_silently=False):
        guess = str(guess).upper().strip()
        try:
            if len(guess) != (length or len(self.secret_word)):
                raise self.InvalidGuess("Wrong length for a guess!")
            if any(not char.isalpha() for char in guess):
                raise self.InvalidGuess("Guesses must be letters only.")
            if self.__dictionary is not None:
                if guess not in self.__dictionary:
                    raise self.InvalidGuess("Unrecognized word.")
                if guess in self.__valid_guesses:
                    raise self.AlreadyGuessed("Already guessed!")
        except (self.InvalidGuess, self.AlreadyGuessed):
            if not fail_silently:
                raise
        else:
            return guess

    @property
    def completed_games(self):
        return self.__completed_games

    @property
    def guessed_letters(self):
        return tuple(self.__guessed_letters)

    @property
    def max_guesses(self):
        return self.__max_guesses

    @property
    def scores(self):
        score_counts = collections.Counter(self.__scores)

        def percent(s):
            return f"{round((score_counts[s] / len(self.__scores)) * 100, 1)}%"

        return {s: percent(s) for s in range(1, 7)}

    @property
    def secret_word(self):
        return self.__secret_word

    @property
    def solved(self):
        return bool(self.__valid_guesses) and sum(self._evaluate_guess()) == len(
            self.secret_word
        )

    def stats(self):
        print("Total games played:", self.completed_games)
        print("Longest win streak:", self.streak)
        if self.completed_games:
            print(
                "Win Rate:",
                f"{round((len(self.__scores) / self.completed_games) * 100, 1)}%",
            )
        if self.scores:
            print()
            scores = self.scores
            for score in range(1, 7):
                print(f"{score}: {self.scores[score]}")

    @property
    def streak(self):
        return self.__streak

    @property
    def valid_guesses(self):
        return tuple(self.__valid_guesses)

    @property
    def win_message(self):
        match len(self.__valid_guesses):
            case 0:
                return "Unbelievable!"
            case 1:
                return "Genius!"
            case 2:
                return "Magnificent!"
            case 3:
                return "Impressive."
            case 4:
                return "Splendid."
            case 5:
                return "Great."
            case 6:
                return "Phew..."


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="Wrdl",
        description="A small Wordle clone that can vary the board size somewhat.",
        epilog="Enjoy Wrdl! :)",
    )
    parser.add_argument("-l", "--length", default=5)
    parser.add_argument("-m", "--max-guesses", default=6)
    parser.add_argument("-i", "--interactive", action="store_true")
    args = parser.parse_args()
    game_engine = Wrdl(length=args.length, max_guesses=args.max_guesses)
    game_engine.play(demo=not args.interactive)
